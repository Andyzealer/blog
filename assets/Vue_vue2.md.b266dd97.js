import{_ as e,c as a,o as i,a as t}from"./app.77068e70.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"MVVM","slug":"mvvm","link":"#mvvm","children":[]},{"level":2,"title":"响应式原理","slug":"响应式原理","link":"#响应式原理","children":[{"level":3,"title":"Observer","slug":"observer","link":"#observer","children":[]},{"level":3,"title":"Watcher","slug":"watcher","link":"#watcher","children":[]},{"level":3,"title":"Compile","slug":"compile","link":"#compile","children":[]}]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":2,"title":"Diff算法","slug":"diff算法","link":"#diff算法","children":[]},{"level":2,"title":"computed 和 watch","slug":"computed-和-watch","link":"#computed-和-watch","children":[]},{"level":2,"title":"data为什么是一个函数","slug":"data为什么是一个函数","link":"#data为什么是一个函数","children":[]},{"level":2,"title":"nextTick","slug":"nexttick","link":"#nexttick","children":[{"level":3,"title":"原因","slug":"原因","link":"#原因","children":[]},{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]}]},{"level":2,"title":"keep-alive","slug":"keep-alive","link":"#keep-alive","children":[]},{"level":2,"title":"插槽","slug":"插槽","link":"#插槽","children":[]},{"level":2,"title":"v-model","slug":"v-model","link":"#v-model","children":[]}],"relativePath":"Vue/vue2.md"}'),r={name:"Vue/vue2.md"},l=t('<h2 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-hidden="true">#</a></h2><p>Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。以前是操作DOM结构更新视图，现在是数据驱动视图。</p><h2 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-hidden="true">#</a></h2><p>采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><h3 id="observer" tabindex="-1">Observer <a class="header-anchor" href="#observer" aria-hidden="true">#</a></h3><p>Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher</p><h3 id="watcher" tabindex="-1">Watcher <a class="header-anchor" href="#watcher" aria-hidden="true">#</a></h3><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p><ul><li>在自身实例化时往属性订阅器(dep)里面添加自己<br><code>todo: Dep()</code></li><li>自身必须有一个update()方法</li><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li></ul><h3 id="compile" tabindex="-1">Compile <a class="header-anchor" href="#compile" aria-hidden="true">#</a></h3><p>Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-hidden="true">#</a></h2><h2 id="diff算法" tabindex="-1">Diff算法 <a class="header-anchor" href="#diff算法" aria-hidden="true">#</a></h2><p><a href="https://juejin.cn/post/6994959998283907102" target="_blank" rel="noreferrer">https://juejin.cn/post/6994959998283907102</a> 虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM，虚拟DOM和虚拟DOM算法是两种概念。虚拟DOM算法 = 虚拟DOM + Diff算法</p><h2 id="computed-和-watch" tabindex="-1">computed 和 watch <a class="header-anchor" href="#computed-和-watch" aria-hidden="true">#</a></h2><p>computed有缓存</p><h2 id="data为什么是一个函数" tabindex="-1">data为什么是一个函数 <a class="header-anchor" href="#data为什么是一个函数" aria-hidden="true">#</a></h2><p>引用同一个地址，会互相影响；函数return对象，每一个对象是新的地址不会相互影响</p><h2 id="nexttick" tabindex="-1">nextTick <a class="header-anchor" href="#nexttick" aria-hidden="true">#</a></h2><p>DOM更新循环结束后执行延迟回调，再修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM。</p><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-hidden="true">#</a></h3><p>Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</p><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-hidden="true">#</a></h3><p>异步调用callback</p><h2 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-hidden="true">#</a></h2><p>keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。</p><h2 id="插槽" tabindex="-1">插槽 <a class="header-anchor" href="#插槽" aria-hidden="true">#</a></h2><h2 id="v-model" tabindex="-1">v-model <a class="header-anchor" href="#v-model" aria-hidden="true">#</a></h2>',28),d=[l];function h(n,c,s,o,p,u){return i(),a("div",null,d)}const m=e(r,[["render",h]]);export{f as __pageData,m as default};
